Chương trước đã giới thiệu về bên trong bộ nhớ tiến trình và đặt nền tảng cho bạn để tiến sâu vào phân tích. Bây giờ, bạn sẽ thấy một số ví dụ cụ thể về cách bạn có thể phát hiện phần mềm độc hại ẩn trong bộ nhớ tiến trình bằng cách gỡ bỏ liên kết thư viện liên kết động (DLL) hoặc sử dụng một trong bốn phương pháp khác nhau để tiêm mã. Bạn cũng sẽ tìm hiểu các kiến thức cơ bản về cách sao chép các tiến trình, thư viện và các module nhân hạt nhân (bất kỳ tệp thực thi có thể chuyển giao [PE]) từ bộ nhớ, bao gồm các mẫu ban đầu đã được đóng gói hoặc nén.

## Process Environment Block

Mỗi cấu trúc _EPROCESS chứa một thành viên gọi là Process Environment Block (PEB). PEB chứa đường dẫn đầy đủ đến tệp thực thi của tiến trình, dòng lệnh đầy đủ để khởi động tiến trình, thư mục làm việc hiện tại, các con trỏ tới các heaps của tiến trình, các handles tiêu chuẩn và ba danh sách liên kết hai chiều chứa đường dẫn đầy đủ đến các DLL đã được nạp bởi tiến trình.

**Mục tiêu**

- Khôi phục dòng lệnh và đường dẫn của quá trình: Tìm hiểu về các nguồn trong bộ nhớ quá trình có thể cung cấp thông tin về cách mà một quá trình được gọi và nơi tệp của nó nằm trên đĩa.
- Phân tích heaps: Tìm hiểu những loại dữ liệu mà các ứng dụng lưu trữ trên heaps của họ và xem một ví dụ thực tế tìm văn bản đã gõ vào Notepad.
- Kiểm tra biến môi trường: Tìm hiểu cách phát hiện hijacking thứ tự tìm kiếm và các họ malware đánh dấu sự hiện diện của họ bằng cách tạo biến mới.
- Phát hiện cửa sau với handles tiêu chuẩn: Xác định xem đầu vào và đầu ra của một quá trình có đang được chuyển hướng qua một remote network socket tới một attacker hay không.
- Liệt kê DLLs: Tìm hiểu cách hệ điều hành theo dõi DLLs được nạp bởi một quá trình, cũng như các API bạn sử dụng trên hệ thống hoạt động để liệt kê chúng. Đồng thời, bạn sẽ thấy cách phát hiện các thư viện ẩn và không liên kết.
- Trích xuất tệp PE từ bộ nhớ: Tìm hiểu cách trích xuất các tệp PE từ bộ nhớ và chuẩn bị chúng để phân tích tĩnh với disassembler. Bạn sẽ tiếp xúc với cách PE file thay đổi khi nạp vào bộ nhớ và cách những thay đổi này có thể ảnh hưởng đến cuộc điều tra của bạn.
- Phát hiện mã tiêm: Xem mô tả chi tiết về bốn loại mã tiêm mã, bao gồm cách phát hiện chúng bằng cách sử dụng phân tích nhớ.

**Cấu trúc dữ liệu**

Cấu trúc chính _PEB được đặt tên phù hợp là _PEB. Mã sau đây cho thấy cấu trúc _PEB cho một hệ thống Windows 7 64-bit, cùng với các cấu trúc cho thông số quá trình và DLLs. Hãy nhớ rằng cấu trúc _PEB tồn tại trong bộ nhớ quá trình, vì vậy một quá trình có thể dễ dàng sửa đổi giá trị của nó để báo cáo thông tin sai hoặc ngăn cản việc phân tích. Sau đó trong chương, bạn sẽ thấy cách tận dụng dữ liệu trong kernel (như các mô tả địa chỉ ảo [VADs] và bảng trang) để chéo tham chiếu với một số thông tin có sẵn trong PEB.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183451.png)

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183507.png)

Những điểm chính về _PEB là như sau:
- BeingDebugged: Cho biết liệu tiến trình đang được gỡ lỗi (debug) hay không. Trong quá khứ, chúng tôi đã gặp phần mã độc thời gian thực hiện tự đính kèm vào chính nó (bằng cách gọi DebugActiveProcess). Vì chỉ một trình gỡ lỗi được đính kèm vào một quá trình mục tiêu tại một thời điểm, nó đã hoạt động như bảo vệ chống gỡ lỗi. Do đó, nếu giá trị này được đặt thành true, nhưng không có bất kỳ trình gỡ lỗi hợp lệ nào đang chạy, đó là một dấu hiệu đáng ngờ.

- ImageBaseAddress: Địa chỉ trong bộ nhớ quá trình mà tập tin thực thi chính (.exe) được tải lên. Trước khi plugin procdump của Volatility (được miêu tả sau trong chương) trích xuất một tập tin thực thi từ bộ nhớ, nó đọc giá trị này để biết nơi để tìm kiếm.

- Ldr: Trỏ tới một cấu trúc _PEB_LDR_DATA, chứa thông tin về các DLL đã được tải trong một quá trình.

- ProcessParameters: Trỏ tới một cấu trúc _RTL_PROCESS_PARAMETERS (được miêu tả sớm).

- ProcessHeap: Heap chính cho quá trình, được tạo tự động khi quá trình được khởi tạo.

- NumberOfHeaps: Số lượng heap trong một quá trình. Mặc định, một quá trình chỉ có một heap, nhưng có thể tạo thêm bằng cách gọi HeapCreate.

- ProcessHeaps: Một mảng con trỏ tới các heap của quá trình. Mục nhập đầu tiên trong danh sách này luôn luôn trỏ tới cùng một vị trí với ProcessHeap vì đó là heap chính.

Những điểm chính về _RTL_PROCESS_PARAMETERS là như sau:
- StandardInput: Handle đầu vào tiêu chuẩn của tiến trình.
- StandardOutput: Handle đầu ra tiêu chuẩn của tiến trình.
- StandardError: Handle lỗi tiêu chuẩn của tiến trình.
- CurrentDirectory: Thư mục làm việc hiện tại của ứng dụng.
- ImagePathName: Đường dẫn đầy đủ của tập tin thực thi (.exe) trên đĩa. Thường bạn cần xem giá trị này vì _EPROCESS.ImageFileName (được in ra bởi plugin pslist) chỉ chứa 16 ký tự đầu tiên và không bao gồm Unicode.
- CommandLine: Dòng lệnh đầy đủ, bao gồm tất cả các tham số, được sử dụng để gọi tiến trình.
- Environment: Con trỏ tới các biến môi trường của tiến trình.

Những điểm chính về _PEB_LDR_DATA là như sau. Tất cả các danh sách liên kết chứa các phần tử của kiểu _LDR_DATA_TABLE_ENTRY, sẽ được miêu tả tiếp theo. Lưu ý, trong ngữ cảnh này, thuật ngữ "module" (module) đề cập đến bất kỳ hình ảnh thực thi nào, bao gồm cả tập tin thực thi của tiến trình và các DLL.
- InLoadOrderModuleList: Danh sách liên kết sắp xếp các module theo thứ tự chúng được tải vào tiến trình. Vì tệp thực thi của tiến trình luôn là module đầu tiên được tải vào không gian địa chỉ của tiến trình, nên bản ghi của nó là đầu tiên trong danh sách này.
- InMemoryOrderModuleList: Danh sách liên kết sắp xếp các module theo thứ tự chúng xuất hiện trong bố cục bộ nhớ ảo của tiến trình. Ví dụ, DLL cuối cùng được tải có thể kết thúc tại một địa chỉ cơ sở thấp hơn DLL đầu tiên (do randomization bố cục không gian địa chỉ [ASLR] và các yếu tố khác).
- InInitializationOrderModuleList: Danh sách liên kết sắp xếp các module theo thứ tự chúng thực thi hàm DllMain của mình. Điều này khác với danh sách thứ tự tải vì hàm DllMain của một module không luôn được gọi ngay khi nó tải. Đôi khi nó không bao giờ được gọi, ví dụ khi bạn tải một DLL như một tệp dữ liệu hoặc tài nguyên hình ảnh (xem tham số dwFlags cho LoadLibraryEx).

Những điểm chính về _LDR_DATA_TABLE_ENTRY là như sau:
- DllBase: Đây là địa chỉ cơ sở của module trong bộ nhớ của tiến trình. Các plugin rút trích DLL mà bạn sẽ tìm hiểu sau trong chương sẽ đọc địa chỉ này để biết nơi bắt đầu khắc phục.
- EntryPoint: Là lệnh đầu tiên được thực thi bởi module. Trong hầu hết các trường hợp, nó được lấy từ giá trị AddressOfEntryPoint của tệp PE.
- SizeOfImage: Kích thước của module, tính bằng byte.
- FullDllName: Đường dẫn đầy đủ đến tệp của module trên đĩa (ví dụ: C:\Windows\System32\kernel32.dll).
- BaseDllName: Phần cơ sở của tên tệp của module (ví dụ: kernel32.dll).
- LoadCount: Số lần gọi LoadLibrary cho module. Nó được sử dụng như một đếm tham chiếu để biết khi nào có thể an toàn để gỡ bỏ một DLL khỏi bộ nhớ của tiến trình. Bạn sẽ thấy giá trị này sau trong chương để xác định cách một DLL được tải (thông qua bảng địa chỉ nhập [IAT] hoặc một cuộc gọi rõ ràng đến LoadLibrary).

### Process Heaps

Từ quan điểm pháp lý, khi bạn rút trích bộ nhớ tiến trình thông qua memdump hoặc vaddump, bạn tất nhiên sẽ nhận được nội dung heap (ít nhất là các trang không được đổi chỗ). Tương tự, điều này cũng áp dụng khi quét bộ nhớ bằng Yara và API search_process_memory đã thảo luận trong Chương 7. Vấn đề là bạn không nhất thiết phải biết offsets nào trong tệp dump hoặc kết quả chữ ký của bạn tương ứng với các khu vực heap. Hơn nữa, trong một số trường hợp, bạn có thể chỉ muốn phân tích heap memory. Ví dụ, giả sử bạn đang tìm kiếm dữ liệu mà ứng dụng đã nhận được qua mạng hoặc văn bản mà người dùng đã nhập vào bộ xử lý văn bản. Những loại dữ liệu này có khả năng cao được lưu trữ trên một trong những heap của quy trình, vì vậy không cần phải lãng phí thời gian quét các khu vực bộ nhớ chứa DLL, ngăn xếp hoặc các tệp được ánh xạ.

>**Lưu ý:**<br> Để có cái nhìn tổng quan về cấu trúc và nội bộ của bộ nhớ heap hiện đại, bạn có thể tham khảo tài liệu "Windows 8 Heap Internals" của Chris Valasek và Tarjei Mandt tại địa chỉ: http://illmatics.com/Windows%208%20Heap%20Internals.pdf

### Finding Text on Notepad’s Heap

Ví dụ này giới thiệu cách giảm thiểu không gian tìm kiếm đáng kể khi tìm kiếm chứng cứ pháp lý trên heap. Nghiên cứu được khởi đầu khi một thành viên của danh sách thư Volatility hỏi câu hỏi sau: Làm cách nào để tìm thấy văn bản mà người dùng đã nhập vào Notepad? Một cách, tất nhiên, là đảo ngược notepad.exe và xác định nơi nó lưu trữ con trỏ đến dữ liệu mà ứng dụng nhận từ bàn phím. Tuy nhiên, chúng tôi đã chọn một cách tiếp cận dễ dàng hơn, hơn nữa là hộp đen hơn. Trước tiên, để thiết lập môi trường, chúng tôi đã khởi chạy hai phiên bản của Notepad: một phiên bản mở một tệp nhật ký khá lớn và phiên bản kia được sử dụng bởi "đối tượng nghi vấn" để lập kế hoạch thực hiện một tội ác (mà bạn đang điều tra). Một ví dụ về màn hình desktop của đối tượng nghi vấn được hiển thị trong Hình 8-1.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183529.png)

Giả sử bạn đã có một bản sao bộ nhớ từ hệ thống của đối tượng nghi vấn. Lúc này, bạn có thể chạy các plugin như vadinfo và vadtree trên các quy trình Notepad, nhưng (trên máy cụ thể này) bạn sẽ thấy hơn 50 VAD nodes chứa hơn 25MB dữ liệu trong mỗi quy trình. Làm thế nào để xác định chính xác văn bản hoàn toàn ngẫu nhiên trong một tập hợp 25 triệu byte? Bạn có thể bắt đầu bằng cách loại bỏ chỉ các VAD chứa heap của quy trình.

Như đầu ra sau đây từ các plugin heaps cho thấy, quy trình có PID 3988 có 6 heap. Tổng cộng, điều này thu hẹp tìm kiếm của bạn thành 6 VAD và khoảng 1.3MB dữ liệu. Tại điểm này, phương pháp hộp đen được kích hoạt. Chúng tôi bắt đầu tìm kiếm bất cứ điều gì có thể giúp cô lập các chunk heap chứa văn bản mong muốn khỏi tất cả các chunk khác. Như hiển thị, hai chunk nổi bật vì có cờ "extra" được hiển thị. Nói cách khác, cờ HEAP_ENTRY_EXTRA_PRESENT được đặt trong thành viên _HEAP_ENTRY.Flags cho hai chunk này. Cả hai chunk này tồn tại trong heap chính (chunk đầu tiên trong mảng ProcessHeaps) bắt đầu từ địa chỉ 0xa0000.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183544.png)

Bất kể ý nghĩa thực sự của cờ "extra" (chúng tôi chưa tìm thấy mô tả tốt), điều này là sự không nhất quán khiến chúng tôi chú ý đến các đoạn mã tại địa chỉ 0xa8028 và 0xac7b0. Lệnh volshell dưới đây cho thấy rằng một trong những đoạn mã này thực sự chứa một phiên bản Unicode của văn bản mà chúng tôi nghi ngờ. Lưu ý rằng văn bản thực sự bắt đầu từ địa chỉ 0xac7b8 do một _HEAP_ENTRY tồn tại ở đầu, có kích thước là 8 byte trên nền tảng 32-bit.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183655.png)

Lúc này, chúng tôi đã tạo một plugin cho Notepad để tự động ghi dữ liệu văn bản từ các tiến trình notepad.exe. Dưới đây là cách dữ liệu đầu ra của plugin trông như:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183719.png)


Mặc dù plugin hoạt động dựa trên ước lượng thông qua các suy luận từ kiến thức đã có thay vì kiểm tra thực nghiệm hoặc đảo ngược mã nguồn, nhưng nó vẫn hoạt động một cách ổn định và chính xác trên các phiên bản 32-bit của hệ điều hành Windows XP và Windows Server 2003. Ngay cả khi không phát hiện được tín hiệu từ cờ "extra", việc giới hạn không gian tìm kiếm chỉ trong khoảng 1.3 MB của toàn bộ bộ nhớ tiến trình bằng cách xem các khu vực chứa heaps vẫn có thể thực hiện được.

### Environment Variables

Đối với một tiến trình, các biến môi trường được trỏ đến bởi _PEB.ProcessParameters.Environment. Các biến này được tổ chức thành nhiều chuỗi kết thúc bằng NULL, tương tự như giá trị REG_MULTI_SZ trong registry. Nếu một kẻ tấn công can thiệp vào các biến này, họ có thể làm cho ứng dụng mục tiêu không mong đợi thực thi một tiến trình độc hại. Ngoài ra, một số phần mềm độc hại đánh dấu sự tồn tại của nó bằng cách tạo các biến môi trường thay vì mutexes. (xem phần "Coreflood Presence Marking")

Do đó, bạn nên biết cách kiểm tra các mục nhập đáng ngờ. Bảng 8-1 phân loại các loại biến theo phạm vi và sự tồn tại của chúng.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183735.png)

Cả Biến Hệ thống (System) và Biến Người dùng (User) đều tồn tại lâu dài trong registry. Vì vậy, bạn có thể liệt kê chúng bằng cách phân tích các tệp registry hive đã được thu thập từ đĩa. Biến Biến đổi (Volatile) cũng được lưu trữ trong registry, nhưng trong một khóa tạm thời (volatile key), do đó, bạn phải truy cập chúng bằng cách thu thập RAM và sử dụng chức năng hỗ trợ registry được lưu trữ trong Volatility (xem Chương 10). Biến Biến đổi thường được đặt trong mỗi tiến trình khi một luồng trong tiến trình gọi hàm SetEnvironmentVariable. Tương tự như Biến Biến đổi, các mục nhập này chỉ được tìm thấy trong bộ nhớ, chúng không bao giờ được ghi vào các tệp registry trên đĩa hay bất kỳ tệp log nào khác.

Khi một tiến trình được tạo, thông thường nó sẽ kế thừa khối môi trường từ tiến trình cha. Tiến trình cha có thể ghi đè lên hành vi mặc định này bằng cách chỉ định tham số lpEnvironment khi gọi hàm CreateProcess. Dưới đây là danh sách các loại dữ liệu bạn thường thấy trong các biến môi trường:

- Đường dẫn đến các chương trình thực thi (PATH)
- Phần mở rộng được gán cho các chương trình thực thi (PATHEXT)
- Đường dẫn đến các thư mục tạm thời
- Đường dẫn đến các thư mục Tài liệu, Lịch sử Internet và Dữ liệu Ứng dụng của người dùng
- Tên người dùng, tên máy tính và tên miền
- Vị trí của cmd.exe (ComSpec)

#### Attacks on Environment Variables

Hai loại tấn công thông thường nhất vào biến môi trường bao gồm thay đổi biến PATH và biến PATHEXT. Thay đổi các giá trị này có hiệu quả tương tự như tấn công "search-order hijacking" (đánh cắp thứ tự tìm kiếm). Ví dụ, xem xét tình huống sau đây:

```
PATH=C:\windows;C:\windows\system32
PATH=C:\Users\HR101\.tmp;C:\windows;C:\windows\system32
```

Trong trường hợp này, nếu biến PATH được cập nhật trong explorer.exe và người dùng đăng nhập đi tới Start ➪ Run và nhập "calc", hệ thống sẽ tìm kiếm một ứng dụng có tên "calc" trong thư mục C:\users\HR101.tmp trước khi nó kiểm tra các thư mục windows và system32. Do đó, người dùng sẽ không mong đợi thực thi mã độc hại. Tương tự, biến PATHEXT chứa một danh sách các phần mở rộng được tìm kiếm nếu người dùng không chỉ định một phần mở rộng cụ thể. Ví dụ, nếu bạn nhập "calc" như đã đề cập trước đó, hệ thống sẽ tìm kiếm calc.com trước, sau đó là calc.exe, sau đó là calc.bat, và cứ tiếp tục như vậy. Do các sửa đổi sau đây, một kẻ tấn công có thể đặt một tệp có tên là calc.zzz trong một trong các thư mục được tìm kiếm, và tệp này sẽ được thực thi trước:

```
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE
PATHEXT=.ZZZ;.COM;.EXE;.BAT;.CMD;.VBS;.VBE
```

Tất nhiên, trong những tình huống này, mã độc ác được kích hoạt sẽ tiếp tục khởi chạy chương trình calc.exe hợp pháp—để người dùng không bắt đầu nghi ngờ có sự đánh lừa.

#### Coreflood Presence Marking

Nhiều mẫu mã độc hại đánh dấu sự hiện diện của chúng trên hệ thống bằng cách tạo mutex toàn cầu có thể truy cập. Điều này giúp ngăn ngừa việc tái lây nhiễm do sơ ý. Mutex cũng cung cấp một chỉ mục pháp lý mạnh mẽ. Coreflood sử dụng biến môi trường với mục đích rất tương tự - để đánh dấu sự hiện diện của nó trong một tiến trình. Bởi vì thành phần chính của Coreflood là một DLL, các tác giả cần một cách để đảm bảo rằng cùng một tiến trình không bị tiêm mã độc nhiều hơn một lần. Do đó, họ đã lập trình hàm nhập DLL để tạo một chuỗi được tạo một cách giả tạo ngẫu nhiên dựa trên PID của tiến trình cha và số serial của ổ đĩa. Sau đó, chuỗi này được thêm vào biến môi trường của tiến trình bằng cách gọi hàm SetEnvironmentVariable, nếu nó chưa tồn tại. Nếu đã tồn tại, DLL sẽ được hủy ngay lập tức. Biểu đồ của hàm nhập DLL của DLL (được tạo bởi IDA Pro) được hiển thị trong Hình 8-2.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183751.png)


Một câu đố thú vị mà chúng tôi thích hỏi sinh viên trong lớp đào tạo của chúng tôi là: Dựa vào những gì bạn vừa học, có bao nhiêu trong số các tiến trình sau đây bị nhiễm mã độc của DLL Coreflood? Lưu ý rằng chúng tôi đang sử dụng plugin envars của Volatility để liệt kê các biến trong bộ nhớ đã được dump.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183804.png)

Nếu bạn đã trả lời là "hai," thì bạn đúng. Ban đầu, có vẻ như tất cả bốn tiến trình đều bị nhiễm mã độc, vì chúng đều chứa các tên biến đáng ngờ. Tuy nhiên, chúng ta đã đề cập trước đó rằng các tiến trình con thường thừa hưởng biến từ tiến trình cha của chúng. Chúng ta cũng nói rằng tên biến phụ thuộc vào PID của tiến trình. Nếu cả bốn tiến trình đều bị nhiễm mã độc, bạn sẽ thấy bốn tên biến duy nhất; nhưng bạn chỉ thấy hai (VFTPXXPYVTAMF và QBYXKDAGXM). Ba tiến trình cuối (IEXPLORE.EXE, notepad.exe và firefox.exe) đã được sinh ra bởi PID 1144, điều này giải thích tại sao chúng có một bản sao của biến VFTPXXPYVTAMF. Bạn cũng sẽ thấy rằng IEXPLORE.EXE thực sự có hai biến: một biến được thừa hưởng từ tiến trình cha và một biến Coreflood tính toán cho PID riêng của nó.

>**GHI CHÚ:**<br> Tùy chọn --silent cho plugin envars sẽ khiến nó ẩn các biến đã biết (dựa trên một danh sách trắng được lập trình cứng). Điều này hữu ích trong những tình huống mà tên biến hoặc giá trị của nó không rõ ràng; ví dụ, như VFTPXXPYVTAMF.

### Standard Handles

Bằng cách phân tích các "standard handles" của một tiến trình, bạn có thể xác định nơi mà tiến trình nhận đầu vào và gửi đầu ra cũng như thông báo lỗi. Điều này đặc biệt hữu ích khi điều tra các vi phạm tiềm năng do các kẻ tấn công từ xa thực hiện. Ví dụ, một cách khá phổ biến để tạo ra một cửa sổ lệnh đằng sau trên hệ thống là thông qua việc tạo một phiên bản của cmd.exe và chuyển hướng các "standard handles" của nó qua named pipes hoặc socket mạng. Do đó, kẻ tấn công có thể sử dụng telnet hoặc netcat để kết nối đến máy mục tiêu (nếu không có tường lửa chặn truy cập), và nhập lệnh như khi họ đang ngồi tại bảng điều khiển. Đoạn mã sau đây hiển thị mã nguồn C liên quan cho một cửa sổ sau sử dụng kỹ thuật này:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183825.png)

Các dòng mã 1-3 cấu hình một socket IPv4 sẽ lắng nghe trên tất cả các giao diện (INADDR_ANY) trên cổng 31337. Dòng 5-10 gán địa chỉ cục bộ cho socket. Sau đó, hàm vào vòng lặp while (dòng 12-33) sẽ thực thi liên tục trong khi tiến trình đang chạy. Ở dòng 16-20, chương trình bắt đầu lắng nghe trên cổng và gọi hàm accept để chờ các kết nối từ các khách hàng. Sau khi nhận được kết nối từ một khách hàng, nó thiết lập các thông số cho tiến trình con cmd.exe ở dòng 25. Cụ thể, nó bật cờ STARTF_USESTDHANDLES trong khối _STANDARD_INFORMATION (mySi) và sau đó đặt các giá trị hStdError, hStdInput và hStdOutput thành socket khách hàng (myCliSock). Cuối cùng, ở dòng 30-32, phiên cmd.exe được bắt đầu. Lưu ý rằng bInheritHandles được đặt thành 1, điều này có nghĩa là tiến trình con sẽ thừa hưởng một bản sao của các handles của tiến trình cha (cụ thể là cho quyền truy cập vào socket handle myCliSock).

Tại thời điểm này, bất kỳ lệnh nào mà kẻ tấn công nhập qua mạng sẽ được đưa trực tiếp vào cmd.exe qua đầu vào chuẩn của nó. Kết quả sẽ được truyền trở lại cho khách hàng qua đầu ra chuẩn. Nếu bạn đang điều tra máy nạn nhân và thấy cmd.exe đang chạy, bạn có thể không nghĩ có gì đáng chú ý. Tuy nhiên, bạn đã bỏ qua một bằng chứng quan trọng nhất. Hãy xem cách các bộ đầu vào/ra chuẩn xuất hiện đối với quy trình đang tham gia vào hoạt động của cửa sau:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183843.png)

Trên máy tính đang chạy bốn phiên bản của cmd.exe. Ba phiên bản đầu tiên có giá trị bình thường cho đầu vào chuẩn (0x3), đầu ra chuẩn (0x7) và lỗi chuẩn (0xb). Phiên bản cuối cùng, có PID là 2160, hiển thị giá trị 0x68 cho tất cả các handle. Bạn có thể xác định liệu 0x68 tương ứng với một named pipe hay network socket bằng cách sử dụng plugin handles, như được thể hiện trong đầu ra dưới đây. Trong Chương 11, bạn sẽ tìm hiểu rằng các handle mở tới \Device\Afd\Endpoint chỉ ra hoạt động mạng (Afd là Auxiliary Function Driver cho Winsock).

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183908.png)

Mặc dù cmd.exe không tạo bất kỳ socket nào, nó có quyền truy cập vào chúng nhờ vào việc thừa hưởng. Bạn có thể xác định chính xác cổng mà cửa sổ sau sử dụng, cũng như điểm cuối từ xa nếu có kết nối hiện đang được thiết lập, bằng cách trước tiên tra cứu tiến trình cha của cmd.exe, sau đó liệt kê thông tin mạng của nó (xem Chương 11). Bạn có thể hoàn thành hai hành động này bằng cách sử dụng các plugin pstree và netscan, như được hiển thị trong đầu ra dưới đây:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183924.png)


Cha của cmd.exe có PID 2160 là memen.exe có PID 1400. Tiến trình cha này có một socket IPv4 đang lắng nghe trên cổng 31337 và một kết nối đã thiết lập (điểm cuối từ xa đã được ẩn). Đây là một ví dụ thú vị vì hoạt động mạng chính được liên kết với tiến trình cha, memen.exe, trong khi tiến trình con là tiến trình được sử dụng thực tế để thực thi lệnh và truyền kết quả trở lại cho kẻ tấn công.

### Dynamic Link Libraries (DLLs)

Các DLL (Dynamic Link Libraries) chứa mã và tài nguyên có thể được chia sẻ giữa nhiều tiến trình. Chúng được phổ biến trong các phần mềm độc hại và kẻ tấn công vì DLL được thiết kế để chạy bên trong một tiến trình chủ, do đó cung cấp quyền truy cập vào tất cả các tài nguyên của tiến trình đó: các luồng, handles và toàn bộ vùng nhớ của tiến trình. Hơn nữa, DLL cho phép các bộ công cụ có tính modular và có thể mở rộng. Ít nhất, khi phân tích DLL, bạn nên kiểm tra các điểm sau:

- Những khác biệt trong danh sách (List discrepancies): Như bạn sẽ tìm hiểu sau đó, kẻ tấn công cố gắng giấu các DLL của họ bằng cách gỡ liên kết các cấu trúc siêu dữ liệu khỏi một hoặc nhiều danh sách hoặc ghi đè lên các trường tên hoặc đường dẫn trong các cấu trúc siêu dữ liệu. Bạn có thể phát hiện các cố gắng như vậy bằng cách chéo tham chiếu.

- Đường dẫn tên không đáng mong đợi (Unexpected name paths): Hãy cẩn trọng với các DLL có tên đáng ngờ (ví dụ: sodapop.dll) cũng như các tên giống như nhưng có vị trí không tiêu chuẩn (ví dụ: C:\Windows\system32\sys\kernel32.dll). Chúng tôi cũng đã thấy phần mềm độc hại tải các DLL từ các phân vùng nằm ngoài phân vùng NTFS. Ví dụ, một biến thể TDL tham chiếu đến một module có đường dẫn bắt đầu bằng \\.\globalroot\Device\svchost.exe.

- Ngữ cảnh (Context): Các DLL như ws2_32.dll, crypt32.dll, hnetcfg.dll và pstorec.dll được sử dụng cho việc mạng, mật mã hóa, bảo trì tường lửa và truy cập vào bộ nhớ được bảo vệ, tương ứng. Chúng không đáng ngờ về bản chất, nhưng bạn phải xem xét mục đích của ứng dụng mà chúng được tải lên.

#### How DLLs Are Loaded

DLLs có thể được tải theo các cách sau:

- Dynamic linking (Liên kết động): Là một phần của các quy trình khởi tạo tiến trình, bất kỳ DLL nào trong bảng IAT (Import Address Table) của tệp thực thi (.exe) đều tự động tải vào không gian địa chỉ của tiến trình.

- Dependencies (Phụ thuộc): Các DLL cũng có bảng nhập khẩu (import table), do đó, khi chúng được tải, tất cả các DLL bổ sung mà chúng phụ thuộc vào cũng được tải vào không gian địa chỉ của tiến trình. Để biết thêm thông tin, xem Dependency Walker (http://www.dependencywalker.com/).

- Run-time dynamic linking (RTDL) (Liên kết động thời gian chạy): Một luồng có thể tường minh gọi hàm LoadLibrary (hoặc LdrLoadDll trong trường hợp native) với tên của DLL cần tải. Kết quả cuối cùng cũng giống như khi liên kết động (DLL được tải vào tiến trình), nhưng không có dấu vết của DLL trong bảng IAT của tiến trình.

- Injections (Tiêm): Như bạn sẽ tìm hiểu sau trong chương, DLL có thể được tiêm một cách bắt buộc vào một tiến trình mục tiêu.

#### Enumerating DLLs on Live Systems

Các công cụ nghiên cứu cơ bản của hệ thống của bạn sẽ có khả năng liệt kê các DLL. Ví dụ, Process Hacker và Process Explorer đều hỗ trợ tính năng này. Sysinternals cũng cung cấp một tiện ích dòng lệnh gọi là listdlls (http://technet.microsoft.com/en-us/sysinternals/bb896656.aspx). Từ góc độ lập trình, bạn có thể sử dụng các hàm API của Windows như CreateToolhelp32Snapshot cùng với Module32First và Module32Next. Hoặc bạn có thể sử dụng hàm API khác là EnumProcessModules, đã có từ Windows XP.

Phần quan trọng về các công cụ và các API mà chúng phụ thuộc là nơi chúng lấy thông tin. Như được trình bày trong phần cấu trúc dữ liệu của chương này, ba danh sách liên kết DLL có thể truy cập từ PEB (Process Environment Block). Chúng lưu trữ thông tin về các module theo thứ tự chúng được tải và khởi tạo, cũng như vị trí chúng tồn tại trong bộ nhớ. Các API và công cụ hoạt động thời gian thực thường chỉ xem danh sách thứ tự tải. Điều này tạo cơ hội cho kẻ tấn công can thiệp và giấu các DLL.

#### Hiding DLLs

Như được hiển thị trong Hình 8-3, vì tất cả ba danh sách tồn tại trong bộ nhớ tiến trình, bất kỳ luồng nào đang chạy trong tiến trình cũng có thể gỡ liên kết một cấu trúc siêu dữ liệu (_LDR_DATA_TABLE_ENTRY) để ẩn nó khỏi hệ thống đang chạy (và có thể cả phân tích bộ nhớ). Ví dụ, sau khi được tải, module xyz.dll có thể ghi đè lên các con trỏ Flink và Blink của riêng nó để bỏ qua mục nhập của nó trong quá trình liệt kê.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183941.png)

#### Listing DLLs in Memory

Cách tiếp cận gỡ liên kết như được mô tả trong Hình 8-3 cũng ảnh hưởng đến plugin dlllist của Volatility. Chúng tôi đã thiết kế plugin dlllist như vậy với một lý do. Nó liệt kê các DLL bằng cách đi qua danh sách thứ tự tải, tương tự như các API hoạt động trực tiếp, vì trong một số trường hợp, việc nhìn từ góc độ các công cụ chạy trên hệ thống thời gian thực là điều hữu ích. Dưới đây là một ví dụ đầu ra từ plugin dlllist. Thông qua lớp học đào tạo của chúng tôi, chúng tôi thường hỏi sinh viên xem họ có thể phát hiện bất cứ điều gì đáng ngờ không. Bạn có nhìn thấy điều gì đáng ngờ không?

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20183956.png)

Quá trình thực thi của tiến trình (notepad.exe) được tải lên đầu tiên trong không gian địa chỉ của tiến trình, do đó, nó đứng đầu danh sách thứ tự tải. Tiếp theo, các thư viện hệ thống ntdll.dll và kernel32.dll được tải lên. Sau đó, hệ thống tiếp tục tải bất kỳ DLL nào trong bảng IAT của Notepad và bất kỳ module phụ thuộc nào mà các DLL đó cần. Lưu ý, số lượng tải cho lô đầu tiên của các module là 0xffff. Vì trường này là một số nguyên ngắn, 0xffff thực chất là -1. Một số lượng tải -1 có nghĩa là DLL đã được tải vì nó được chỉ định trong IAT. Các DLL khác gần cuối danh sách, có số lượng tải là 0x3, 0x27, 0x4 và 0x1, được tải bằng cách gọi rõ ràng hàm LoadLibrary.

Mặc dù có rất nhiều lý do hợp lệ để gọi hàm LoadLibrary, nhưng cách sử dụng này cũng phù hợp với các kỹ thuật mà shellcode sử dụng để thiết lập không gian địa chỉ của tiến trình mục tiêu. Bạn có thể thấy rằng không có một DLL được tải bằng cách gọi rõ ràng nào là đáng ngờ trong bản thân nó - tất cả đều có tên đúng đắn và nằm trong đúng đường dẫn system32. Tuy nhiên, khi bạn xem xét mục đích của chúng (liên quan đến mạng) và ngữ cảnh tiến trình chủ (notepad.exe), tình hình bắt đầu trở nên khá bất thường. Có khả năng mã cần truy cập vào các DLL liên quan đến mạng đã nhiễm tiến trình này và nó tải chúng bằng cách gọi LoadLibrary.

>**LƯU Ý:**<br> Bố cục DLL có một chút khác biệt đối với các tiến trình WOW64 (ứng dụng 32-bit trên hệ thống 64-bit). Ba danh sách trong PEB chỉ chứa các DLL mà có thể truy cập được bởi ứng dụng 32-bit (ví dụ: những DLL nằm dưới MmHighestUserAddress) và các DLL tương thích WOW64. Ví dụ, đầu ra của plugin dlllist cho các tiến trình này trông như sau: (Có một ví dụ đầu ra của plugin dlllist không được cung cấp trong câu hỏi, vì vậy tôi không thể hiển thị đầu ra cụ thể. Nếu bạn cung cấp đầu ra, tôi sẽ rất vui được hỗ trợ xác định bất kỳ khía cạnh nào trong đầu ra có thể đáng ngờ.)
![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184021.png)<br>
Các thư viện WOW64 (cùng với ntdll.dll) chứa các điểm nhập cho các ứng dụng 32-bit và mã cần thiết để chuyển sang chế độ 64-bit để luồng gọi có thể truy cập vào các DLL trong các khu vực địa chỉ cao hơn. Như lưu ý đã thông báo, bạn có thể sử dụng plugin ldrmodules (được thảo luận chi tiết ngay sau đó) để liệt kê các DLL trong một tiến trình WOW64 - thậm chí cả các DLL mà thông thường không thể truy cập bởi các ứng dụng 32-bit. <br>Để biết thêm thông tin về các khái niệm này, xem WOW64 Implementation Details: http://msdn.microsoft.com/en-us/library/windows/desktop/aa384274(v=vs.85).aspx.

#### Detecting Unlinked DLLs

Phương pháp ẩn hiện trong Hình 8-3 khá hiệu quả, mặc dù nó đơn giản và nguyên thủy. Tuy nhiên, có nhiều cách mạnh mẽ hơn để ẩn các DLL mà bạn cũng có thể gặp trong môi trường thực tế. Ví dụ, nếu có ba danh sách và phần mềm độc hại ẩn một danh sách, bạn có thể dễ dàng so sánh với hai danh sách còn lại để xem điều gì bị thiếu. Do đó, ngay từ năm 2007 (xem http://www.openrce.org/blog/view/844/How_to_hide_dll), các nhà tấn công trong cộng đồng offensive đã bắt đầu gỡ liên kết các DLL khỏi cả ba danh sách. Kẻ tấn công chỉ cần bao gồm hai đến ba dòng mã bổ sung để cắt cấu trúc siêu dữ liệu khỏi danh sách thứ tự bộ nhớ và danh sách khởi tạo.

Có hai phương pháp giúp bạn phát hiện các DLL bị gỡ liên kết khỏi cả ba danh sách:

- Quét tệp PE: Bạn có thể sử dụng các kỹ thuật đã mô tả trong Chương 7 để thực hiện quét brute force qua bộ nhớ tiến trình, tìm kiếm tất cả các trường hợp của các tệp PE (dựa trên chữ ký tiêu đề MZ đã biết). Tuy nhiên, hãy nhớ rằng các tiêu đề PE cũng nằm trong bộ nhớ tiến trình, vì vậy cùng một đoạn mã gỡ liên kết cấu trúc siêu dữ liệu DLL cũng dễ dàng ghi đè lên chúng.

- Truy xuất VAD: Đây là kỹ thuật được thực hiện bởi plugin ldrmodules của Volatility. Nếu bạn nhớ từ Chương 7, các nút VAD chứa đường dẫn đầy đủ trên đĩa đến các tệp được ánh xạ vào các khu vực, bao gồm cả các tệp DLL. Điểm độc đáo của VAD là chúng tồn tại trong bộ nhớ kernel và những nỗ lực để thao túng cây (tức là gỡ liên kết một nút VAD) hoặc ghi đè lên các con trỏ tệp của chúng nhanh chóng dẫn đến không ổn định hệ thống (màn hình xanh).

Plugin ldrmodules trước tiên liệt kê tất cả các nút VAD chứa các hình ảnh thực thi được ánh xạ. Cụ thể, nó tìm các nút lớn có bảo vệ PAGE_EXECUTE_WRITECOPY, loại VadImageMap và cờ kiểm soát Image được thiết lập. Sau đó, nó so sánh các địa chỉ bắt đầu từ các nút VAD với giá trị DllBase từ các cấu trúc _LDR_DATA_TABLE_ENTRY được tìm thấy trong bộ nhớ tiến trình. Những mục được xác định thông qua VAD mà không được đại diện trong các danh sách DLL có thể bị ẩn. Dưới đây là một ví dụ về đầu ra từ một ví dụ Windows 7 64-bit đã bị nhiễm:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184041.png)

Tệp lpkz2.dll không tồn tại trong bất kỳ danh sách DLL nào trong bộ nhớ tiến trình, nhưng VAD trong bộ nhớ kernel có một bản ghi về nó. Bạn cũng có thể thấy địa chỉ cơ sở của nó là 0x000007feff570000, sau đó bạn có thể truyền nó vào plugin dlldump (được giới thiệu sau trong chương) để trích xuất nó từ bộ nhớ.

Chú ý rằng mục svchost.exe hiển thị False trong cột InInit (danh sách thứ tự khởi tạo). Điều này là ngoại lệ đối với quy tắc về khả năng phát hiện các DLL không kết nối bằng cách chéo kiểm tra nguồn dữ liệu. Bạn sẽ không bao giờ tìm thấy tệp thực thi tiến trình (.exe) trong danh sách thứ tự khởi tạo vì tệp thực thi được khởi tạo khác biệt so với tất cả các module khác. Cụ thể, nó không phải là một DLL, vì vậy không có hàm DllMain được gọi.

>**Cảnh báo:**<br> Phần mềm độc hại cũng đã được biết đến ghi đè lên các thành viên FullDllName và BaseDllName của các cấu trúc _LDR_DATA_TABLE_ENTRY, thay vì gỡ liên kết cấu trúc siêu dữ liệu. McAfee đã báo cáo về một biến thể ZeroAccess hoạt động theo cách này (xem ZeroAccess Misleads Memory-File Link: http://blogs.mcafee.com/mcafee-labs/zeroaccess-misleadsmemory-file-link). Trong trường hợp này, các API trực tiếp trên hệ thống, cùng với plugin dlllist của Volatility, sẽ hiển thị một đường dẫn giả mạo là c:\windows\system32\n, nhưng VAD trong bộ nhớ kernel vẫn chứa đường dẫn gốc đến DLL. Tùy chọn -v/--verbose của ldrmodules sẽ in các đường dẫn đầy đủ từ tất cả các nguồn, và bạn sẽ thấy sự không nhất quán này.

## PE Files in Memory

Một trong những tính năng hữu ích nhất của Volatility là khả năng dump và tái tạo các tệp PE (chương trình thực thi, DLL và trình điều khiển kernel). Do các thay đổi xảy ra trong quá trình thực thi chương trình, không có khả năng bạn sẽ nhận được một bản sao chính xác của tệp nhị phân gốc - hoặc thậm chí là một bản chạy trên máy khác. Tuy nhiên, bản sao được dump nên gần gũi đủ với bản gốc để bạn có thể phân tích ngược mã độc và xác định khả năng của nó, đảo ngược các thuật toán, v.v.

Chúng tôi thường nhận được câu hỏi liệu có thể dump một tệp thực thi và so sánh băm MD5 hoặc SHA1 với tệp trên đĩa. Tuy có thể so sánh các băm mờ (ví dụ: độ tương đồng phần trăm), nhưng các băm mã hóa sẽ không khớp vì các lý do sau đây:

- IAT patching: Trình tải sửa đổi IAT của tệp PE để chứa các địa chỉ của các hàm API trong bộ nhớ tiến trình. Các địa chỉ này cụ thể cho máy và phiên bản của tiến trình từ đó PE được trích xuất.

- Các phần không thể truy cập (Inaccessible sections): Không phải tất cả các phần của PE đều được nạp vào bộ nhớ. Ví dụ, trong một số trường hợp, phần tài nguyên (.rsrc) có thể không được nạp cho đến khi nó cần thiết. Rõ ràng, dữ liệu chưa bao giờ được đọc vào bộ nhớ từ đầu sẽ không thể truy cập khi bạn dump nó.

- Biến toàn cục (Global variables): Một tệp PE có thể xác định các biến toàn cầu hoặc giá trị trong phần dữ liệu đọc / ghi của nó được sửa đổi trong quá trình thực thi. Do đó, khi bạn dump PE từ bộ nhớ, bạn nhận được các giá trị hiện tại, không phải các giá trị ban đầu chưa khởi tạo.

- Mã tự cập nhật (Self-modifying code): Nhiều tệp PE, đặc biệt là tệp độc hại, tự cập nhật mã của chính nó trong thời gian chạy. Ví dụ, các ứng dụng đã đóng gói thực hiện giải nén và / hoặc giải mã các chỉ thị trong bộ nhớ.

Dù bạn nên nhận thức về những khái niệm này, chúng không nhất thiết là những hạn chế hoặc lưu ý trong phân tích bộ nhớ. Trên thực tế, một số trong số chúng có thể thực sự hỗ trợ bạn. Ví dụ, một trong các biến toàn cầu có thể là khóa mã hóa cho lưu lượng điều khiển và điều phối. Tương tự, tệp PE có thể được đóng gói trên đĩa, ngăn bạn tiến hành phân tích tĩnh. Bằng cách dump tệp PE từ bộ nhớ, bạn có thể khôi phục dữ liệu ở định dạng gần giống nhất với trạng thái hiện tại của ứng dụng.

>**GHI CHÚ**<br>
Chúng tôi không bao gồm chi tiết về cấu trúc tập tin PE trong cuốn sách này, nhưng điều này rất hữu ích để biết. Nếu bạn muốn hiểu về điều này nhanh chóng, hãy xem những bài viết kinh điển sau của Matt Pietrek:
>> "An In-Depth Look into the Windows Portable Executable File Format": http://msdn.microsoft.com/en-us/magazine/cc301805.aspx.<br>
>> "Peering Inside the PE: A Tour of the Win32 Portable Executable File Format": http://msdn.microsoft.com/en-us/magazine/ms809762.aspx.

### PE File Slack Space

Một lý do khác khiến các tệp PE dump từ bộ nhớ thường khác biệt so với tệp gốc trên đĩa là do slack space (không gian trống). Kích thước trang nhỏ nhất trên hệ thống Windows x86 hoặc x64 thông thường là 4.096 byte. Hầu hết các tệp PE có các phần không là bội số chính xác của kích thước trang nhỏ nhất này. Hình 8-4 cho thấy tác động của điều này đối với việc tái tạo các tệp nhị phân từ bộ nhớ. Phần .text, không phải là bội số chính xác của 4.096, phải tồn tại hoàn toàn trong bộ nhớ được đánh dấu là RX (đọc, thực thi), và phần .data phải tồn tại hoàn toàn trong bộ nhớ được đánh dấu là RW (đọc, ghi). Vì các bảo vệ được áp dụng ở mức trang (nghĩa là nếu một trang được đánh dấu là thực thi, tất cả các byte trong trang đều có thể thực thi), hai phần này phải được tách riêng nhau sau khi được tải vào bộ nhớ. Nếu không, phần đầu của phần .data sẽ trở thành RX thay vì RW.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184101.png)

Các đoạn chấm đứt trong Hình 8-4 biểu thị các ranh giới trang (page boundaries), và các vùng được tô màu đại diện cho không gian trống (slack space) do kích thước các phần không là bội số của kích thước trang. Trong một số trường hợp, không gian trống chứa chỉ dữ liệu chưa được khởi tạo, làm cho nó không quan trọng đối với cuộc điều tra của bạn. Tuy nhiên, không gian trống cũng có thể chứa chứng cứ quan trọng, đặc biệt khi gặp các tệp đã được đóng gói và các phần bị thay đổi và biến đổi trong quá trình giải nén.

### Parsing PE Headers in Memory


Volatility cung cấp một số API có thể giúp bạn phân tích các tiêu đề PE trong bộ nhớ. Có các plugin tồn tại giúp bọc nhiều chức năng này, vì vậy bạn không cần thực hiện các bước thủ công này. Tuy nhiên, đối với những người quan tâm đến cách các plugin dump PE hoạt động phía sau màn hình, và đặc biệt nếu bạn định phát triển các công cụ riêng của mình dựa trên chức năng tương tự, hướng dẫn sau sẽ hữu ích. Ví dụ, một thời gian trước, chúng tôi đã viết một plugin tùy chỉnh để tìm và tự động trích xuất các tệp nhị phân của ZeroAccess (http://mnin .blogspot.com/2011/10/zeroaccess-volatility-and-kernel-timers.html) bằng cách sử dụng các API dump PE.

Ví dụ sau cho bạn thấy cách sử dụng volshell để xác minh rằng địa chỉ cơ bản được khai báo của tiến trình thực sự chứa chữ ký của một tiêu đề DOS:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184117.png)

Chữ ký MZ có vẻ hoàn chỉnh. Bước tiếp theo để xác nhận định dạng tiêu đề PE là theo e_lfanew để tìm NT header. Thay vì thực hiện việc này bằng tay, bạn có thể tạo một _IMAGE_DOS_HEADER tại địa chỉ cơ bản và sau đó sử dụng hàm get_nt_header. Dưới đây là một ví dụ:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184132.png)

Sau khi có NT header, đoạn mã sau sẽ hiển thị tên, địa chỉ ảo tương đối (RVA) và kích thước ảo của mỗi phần. Để tính toán địa chỉ tuyệt đối của mỗi phần, chỉ cần thêm địa chỉ cơ bản của DOS header vào lệch tương đối. Ví dụ, bạn có thể tìm thấy phần .text tại 0xff080000 + 0x1000 = 0xff081000 cho quy trình này:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184148.png)

Sau khi có một số ý tưởng về cách nội dung tệp PE được tách ra từ bộ nhớ, dưới đây là đoạn mã bạn có thể sử dụng để sao chép từng phần vào đĩa. Bạn có thể truyền một tham số tùy chọn cho hàm get_image để giữ nguyên khoảng trống trống (slack space); tuy nhiên, bạn sẽ đọc thêm về điều đó trong phần tiếp theo. Lưu ý rằng sau khi hoàn thành việc ghi dữ liệu vào tệp (dumped.exe), chúng tôi thoát khỏi volshell và kiểm tra loại tệp đầu ra:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184206.png)

>**Ghi chú:**<br> Sau khi bạn tạo đối tượng _IMAGE_DOS_HEADER trong Volatility, bạn cũng có thể liệt kê các hàm được nhập hoặc xuất của nó, in thông tin phiên bản hoặc thực hiện một số thao tác khác trên tệp PE. Chúng tôi không hiển thị các ví dụ mã ở đây, nhưng bạn có thể xem tệp pe_vtypes.py trong mã nguồn để tìm hiểu cách sử dụng các API này.

### PE Extraction Plugins

Bạn đã thấy các API và nền tảng để Volatility trích xuất tệp PE từ bộ nhớ. Phần này sẽ giới thiệu cho bạn một số plugin hiện có (và các tùy chọn mà chúng có) để tự động hóa quá trình này. Dưới đây là tên và mô tả ngắn của chúng:

- procdump: Dump một tệp thực thi của tiến trình. Bạn có thể xác định tiến trình bằng PID (--pid) hoặc địa chỉ vật lý của _EPROCESS của nó (--offset). Tùy chọn thứ hai cho phép bạn dump các tiến trình bị ẩn khỏi danh sách tiến trình hoạt động.

- dlldump: Dump một DLL. Bạn có thể xác định tiến trình chủ bằng PID (--pid) hoặc địa chỉ vật lý của _EPROCESS của nó (--offset). Nếu DLL nằm trong danh sách thứ tự tải, bạn có thể xác định chúng bằng biểu thức chính quy (--regex/--ignore-case) dựa trên tên của chúng. Nếu không, bạn có thể xác định chúng bằng địa chỉ cơ bản của chúng trong bộ nhớ tiến trình (--base). Tùy chọn thứ hai cho phép bạn dump các tệp PE ẩn hoặc bị tiêm chúc.

- moddump: Dump một module kernel. Tương tự như dlldump, nếu các module mà bạn muốn nằm trong danh sách các module đã tải (xem Chương 13), bạn có thể xác định chúng bằng biểu thức chính quy. Nếu không, để dump một tệp PE từ bất kỳ vị trí nào trong bộ nhớ kernel, hãy sử dụng tham số --base.

Tất cả các plugin đều yêu cầu một thư mục đầu ra (--dump-dir) để ghi các tệp được trích xuất. Tất cả cũng chấp nhận một tham số tùy chọn --memory, đây là cách bạn yêu cầu khai thác không gian trống giữa các phần để được bao gồm trong tệp đầu ra. Do đó, khi bạn sử dụng --memory, tệp được dump sẽ giống với PE như nó tồn tại trong bộ nhớ. Dưới đây là một số ví dụ về việc sử dụng các plugin này. Ví dụ đầu tiên cho thấy cách trích xuất tất cả các tệp thực thi trong danh sách tiến trình hoạt động:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184223.png)

Quá trình trích xuất cho tiến trình System thất bại, nhưng điều này là bình thường - tiến trình này không có tệp thực thi tương ứng. Lưu ý rằng tên của tệp đầu ra được dựa trên PID của tiến trình (executable.PID.exe). Dưới đây là một ví dụ khác cho thấy cách trích xuất một tiến trình không nằm trong danh sách tiến trình hoạt động dựa trên địa chỉ vật lý của _EPROCESS của nó (mà bạn có thể lấy từ psscan hoặc psxview):

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184245.png)

Lệnh tiếp theo trích xuất bất kỳ DLL nào từ PID 1408 mà có tên hoặc đường dẫn khớp với chuỗi "crypt" (không phân biệt chữ hoa chữ thường). Các tệp đầu ra được đặt tên dựa trên PID và địa chỉ vật lý của tiến trình chủ và địa chỉ ảo cơ sở của DLL (module.PID.OFFSET.ADDRESS.dll):

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184259.png)


Bạn có thể sử dụng tùy chọn --base để trích xuất DLL ẩn hoặc bị tiêm vào khi bạn không có tên mà chỉ có địa chỉ cơ sở nơi tiêu đề DOS tồn tại. Đây là cách bạn chỉ định tùy chọn --base:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184315.png)

>**Lưu ý**<br>Cuốn sách này không đi sâu vào các công cụ phân tích thời gian thực, nhưng có thể bạn quan tâm đến các công cụ sau để trích xuất tiến trình từ hệ thống đang chạy:<br>
> - Sysinternals ProcDump và Process Explorer: http://technet.microsoft.com/en-us/sysinternals/dd996900.aspx
> - Process Hacker: http://processhacker.sourceforge.net

### Caveats and Workarounds

Một điều cần lưu ý về các plugin này là chúng dễ bị tấn công bởi những tác động lên giá trị header PE. Ví dụ, nếu không tìm thấy chữ ký MZ hoặc PE, chúng không thể xác định các phần của chương trình. Hơn nữa, chúng cũng phụ thuộc vào các giá trị địa chỉ ảo và kích thước quảng cáo của các phần, mà mã độc có thể dễ dàng ghi đè. Nếu một phần khẳng định nó lớn hơn hoặc nhỏ hơn thực sự là, tập tin đầu ra sẽ chứa dữ liệu dư thừa hoặc mất dữ liệu. Một lý do khác khiến các plugin này có thể thất bại là do sự tình cờ. Nếu các trang chứa thông tin PE hoặc phần thông tin được ghi vào đĩa, các chức năng xác thực header sẽ thất bại. Nếu bạn gặp sự cố khi trích xuất các tập tin PE từ bộ nhớ tiến trình, dù đó là chương trình thực thi hoặc một DLL, bạn luôn có thể quay lại việc chỉ trích xuất các khu vực VAD chứa nó.

Nếu bạn nhớ từ Chương 7, plugin vaddump tạo một tập tin được lót đệm để duy trì toàn vẹn không gian và nó không biết (hoặc quan tâm) đến định dạng tập tin PE. Điều này cho phép bạn vẫn có được dữ liệu ngay cả khi nó đã bị hỏng một cách cố ý. Tuy nhiên, điều này có thể yêu cầu sửa chữa thủ công trước khi nạp vào các công cụ bên ngoài như IDA Pro hoặc các trình xem PE. Một lựa chọn khác là sử dụng plugin dumpfiles (xem Chương 16) để trích xuất các bản sao đã được lưu trữ của các tập tin PE từ đĩa. Trong trường hợp này, bạn sẽ không có slack space, các biến toàn cục đã bị sửa đổi, hoặc các phiên bản đã được giải nén của các tập tin được đóng gói.

## Packing and Compression

Các lớp mã hoá được thêm vào bởi các chương trình bị đóng gói hoặc nén thường được loại bỏ khi chúng tải vào bộ nhớ. Hầu hết các trường hợp, trước khi thực hiện tải phần chính, một chương trình tự hiệu chỉnh thực hiện việc giải nén tại chỗ hoặc di chuyển đến một địa chỉ khác và sau đó thực hiện giải nén. Hình 8-5 mô tả vòng đời của một tệp nhị phân bị đóng gói và sau đó tải vào bộ nhớ. Trước khi đóng gói, điểm nhập của tệp PE nằm trong phần .text của nó (có thể là hàm main hoặc DllMain), và tất cả các chuỗi và mã đều ở dạng văn bản thuần túy. Bạn có thể thực hiện phân tích tĩnh của tệp nhị phân ở giai đoạn này. Tuy nhiên, sau khi tệp được đóng gói, các chuỗi và mã đã được nén và có thể được mã hóa hoặc mã hóa bổ sung. Ngoài ra, một phần mới đã được thêm vào tệp nhị phân chứa mã giải nén và điểm nhập bây giờ dẫn đến phần mới này. Phân tích tĩnh tệp tại điểm này chắc chắn sẽ thất bại.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184332.png)

Khi nhị phân được tải vào bộ nhớ, hàm điểm nhập (mã giải nén) giải nén các chuỗi và dữ liệu gốc để chương trình có thể truy cập chúng. Tiếp theo, hàm main thực sự hoặc DllMain được gọi để thực thi hành vi bình thường của chương trình. Bất kỳ lúc nào từ giờ đến khi DLL bị hủy tải hoặc quá trình kết thúc, bạn nên có thể ghi tệp mã đã giải nén từ bộ nhớ. Việc tìm nó hiếm khi gặp khó khăn vì bạn có dlllist, ldrmodules và malfind (được mô tả trong phần tiếp theo) để cung cấp cho bạn các địa chỉ cơ sở. Kết hợp với procdump, dlldump và moddump, bạn có một bộ công cụ khá linh hoạt để thu thập dữ liệu bạn cần cho phân tích tĩnh.

>**Chú ý**<br> Khả năng của bạn để ghi tệp mã đã giải nén phụ thuộc vào thiết kế của công cụ nén. Đa số các công cụ nén được sử dụng trong thực tế hoạt động theo cách tương tự như mô tả của chúng tôi, nhưng không phải tất cả. Ví dụ, các công cụ nén máy ảo (VM) như VMProtect và Themida gây vấn đề đặc biệt vì chúng không bao giờ giải nén hoàn toàn trong bộ nhớ. Thực tế là mã đã được biến đổi đến mức nhiều khi không thể trích xuất mã gốc. Trong những trường hợp này, chúng tôi thường tập trung vào những tàn tích còn lại trong bộ nhớ khi chương trình thực thi, ví dụ như kết nối mạng, xử lý tệp mở, các dịch vụ chúng tạo ra, và các hoạt động khác.


### Unpacking Malicious Code

Phần này trình bày một ví dụ thực tiễn về việc sử dụng phân tích bộ nhớ để giải nén một mẫu malware. Hình 8-6 hiển thị các hàm mà mẫu đã nén nhập từ kernel32.dll (hiển thị qua CFF Explorer từ http://www.ntcore.com/exsuite.php). Thông thường, bạn có thể xem các hàm nhập của một chương trình và có được một ý tưởng tổng quan về chức năng của nó, nhưng trong trường hợp này bạn không thấy nhiều thông tin - điều này cho thấy công cụ nén làm rối IAT (Import Address Table) cũng như các chỉ thị của chương trình. Tuy nhiên, vì nó bao gồm GetProcAddress và LoadLibraryW, nó có thể tải và truy cập bất kỳ API nào cần thiết tại thời điểm chạy.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20184347.png)

Nếu bạn trích xuất chuỗi từ tệp nhị phân, bạn sẽ thấy không có nhiều chuỗi - ngoại trừ thông điệp DOS và một số mục một phần quen thuộc ở phần đầu. Ví dụ, zirtualAlloc và zegOpenKeyExW rất giống VirtualAlloc và RegOpenKeyExW (tên của các hàm API Windows). Điều này thực sự là đáng ngờ và có thể cho thấy một cố gắng để tránh các chữ ký dựa trên chuỗi.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20203949.png)

Ở điểm này, rõ ràng rằng mẫu này đã được đóng gói. Bạn có thể thực thi nó trong môi trường kiểm soát (như một máy ảo với mạng bị vô hiệu hóa) để cho phép chương trình giải nén trong bộ nhớ. Trong khi chương trình đang chạy, hãy ghi lại trạng thái của nó bằng cách chụp một bản chụp của máy ảo của bạn hoặc trích xuất bộ nhớ. Sau đó, sử dụng procdump để trích xuất mã đã giải nén, như được hiển thị ở đây: 

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204009.png)

Bây giờ sau khi bạn đã có mẫu được trích xuất từ bộ nhớ, hãy chạy lệnh "strings" trên nó để xem sự khác biệt: 

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204028.png)

Kết quả đầu ra cung cấp cho bạn rất nhiều thông tin về chức năng của mã độc. Mặc dù chúng chỉ là các chuỗi, không phải là các liên kết trực tiếp tới mã, nhưng đôi khi đó chính là những gì bạn cần để tạo ra danh sách ban đầu các chỉ báo như địa chỉ IP được liên hệ và các khóa registry được thay đổi.

### Common Unpacking Issues

Bạn có thể tiết kiệm rất nhiều thời gian bằng cách cho phép mã độc tự giải nén trong bộ nhớ thay vì sử dụng bộ gỡ lỗi để đảo ngược mã mẫu. Tuy nhiên, cũng có một số hạn chế. Ví dụ, như đã đề cập trước đó, một số mẫu không bao giờ giải nén hoàn toàn. Bạn cũng có thể gặp phải các mẫu không duy trì hoạt động đủ lâu để bạn có thể chụp bộ nhớ. Trong những trường hợp đó, chúng tôi khuyên bạn nên sử dụng một bộ gỡ lỗi để chạy mã độc và đặt một điểm dừng tại ExitProcess: Nó sẽ "đóng băng" khi bạn truy cập những gì bạn cần. Tất nhiên, bạn cũng có thể tìm thấy các mẫu nhận thức được về bộ gỡ lỗi, vì vậy hãy chắc chắn đọc Recipe 9-11 ("Preventing Processes from Terminating") trong Malware Analyst's Cookbook. Nó sẽ chỉ cho bạn cách tạm dừng quá trình khi nó cố gắng thoát bằng cách đặt các điểm neo trong kernel.

### Unpacking 64-bit DLLs

Việc giải nén các DLL trên Windows 64-bit không khác gì so với các tệp thực thi trên nền tảng 32-bit. Trước khi viết phần này của chương, chúng tôi đã nhận được một mẫu Rovnix (http://www.xylibox.com/2013/10/reversible-rovnix-passwords.html) được triển khai dưới dạng một DLL và nhắm đến các hệ thống 64-bit. Như được thể hiện trong Hình 8-7, mẫu này đã được đóng gói. Nếu bạn không quen thuộc với IDA Pro, thanh ngang dưới trình đơn chính (được gọi là thanh màu) hiển thị các phân đoạn trong tệp chứa các chỉ thị so với dữ liệu chưa xác định. Đa số tệp này không xác định. Ngoài ra, hàm điểm vào cũng gọi tới VirtualAlloc—có thể là để cấp phát một vùng bộ nhớ để sử dụng làm "bảng lưu trữ" nơi giải nén có thể diễn ra. Bạn cũng có thể thấy 62 hàm xuất có tên tương tự như các API cơ sở dữ liệu. Xem mã của chúng (không được hiển thị ở đây), bạn sẽ thấy chúng chỉ là các lệnh no-operation (NOPs).

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204043.png)

Chương 13 (“Working with DLLs”) trong cuốn "Malware Analyst's Cookbook" chứa một số gợi ý hữu ích bạn có thể áp dụng ở đây. Mục tiêu là tải DLL lên sao cho nó có thể giải nén và sau đó giữ nó ở đó đủ lâu để bạn có thể thu thập dữ liệu trong bộ nhớ. Chúng tôi sử dụng "rundll32.exe" (thực tế là một tệp thực thi 64-bit trên các nền tảng 64-bit, mặc dù tên của nó) làm quy trình chủ chạy (host process)—nó sẽ chịu trách nhiệm map DLL độc hại vào bộ nhớ và gọi hàm điểm vào của nó (DllMain). Dưới đây là lệnh mà chúng tôi sử dụng:

```
C:\Users\Elliot\Desktop\> rundll32 dd4382d225a[snip].dll,FakeExport
```

>**Ghi chú:**<br> Tên của hàm xuất bản (exported function) cần gọi là "FakeExport," nhưng tên này không quan trọng lắm. Trước khi "rundll32.exe" tham chiếu đến "FakeExport," DLL độc hại đã được tải lên rồi. Bạn có thể dùng một trong các hàm xuất bản như bạn thấy trong Hình 8-7, hoặc bạn có thể sử dụng tên khác. Đáng ngạc nhiên là bạn không thể bỏ tên hàm xuất bản ra khỏi lệnh, nếu không, "rundll32.exe" sẽ báo lỗi cú pháp.

Sau khi tải DLL lên, bạn nên chụp bộ nhớ (capture memory) và sau đó xác định địa chỉ cơ sở (base address) của nó bằng cách sử dụng dlllist, như được hiển thị dưới đây:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204059.png)

Kết quả hiển thị cho bạn biết rằng DLL được tải lên tại địa chỉ cơ sở (base address) 0x180000000 trong quá trình (process). Bây giờ bạn có thể tiến hành dump DLL như sau:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204115.png)

Khi tập tin được dump và tải vào IDA Pro, bạn thấy sự khác biệt đáng kể. Lưu ý cách tệp đã được giải nén trong Figure 8-8 so với tệp đã được pack ở Figure 8-7 trước đó.

Thanh màu đã thay đổi để chỉ ra rằng hầu hết tệp chứa mã thay vì dữ liệu không xác định. Các hàm xuất liên quan đến cơ sở dữ liệu kỳ lạ đã biến mất, bảng nhập đã được giữ nguyên, và (quan trọng nhất) các chỉ thị trong khung dịch mục không còn bị nén.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204133.png)

## Code Injection

Ứng dụng độc hại sử dụng code injection để thực hiện các hành động từ ngữ cảnh của một tiến trình khác. Khiến một tiến trình hợp pháp thực hiện các hành động thay mặt cho nó, chẳng hạn như tải về các trojan bổ sung hoặc đánh cắp thông tin từ hệ thống. Các tấn công viên có thể tiêm code vào một tiến trình theo nhiều cách, chẳng hạn như ghi vào bộ nhớ của tiến trình từ xa trực tiếp hoặc thêm một khóa registry khiến các tiến trình mới tải một DLL theo sự lựa chọn của kẻ tấn công. Phần này sẽ thảo luận về cách bạn có thể xác định xem có bất kỳ tiến trình nào trên hệ thống là nạn nhân của code injection, và nếu có, bạn sẽ cách bạn có thể trích xuất các đoạn bộ nhớ chứa mã độc hại.

Các lớp của code injection mà chúng tôi đề cập đến là như sau:
- Tiêm DLL từ xa: Một tiến trình độc hại buộc tiến trình mục tiêu tải một DLL cụ thể từ đĩa bằng cách gọi LoadLibrary hoặc LdrLoadDll cơ sở. Theo định nghĩa, DLL phải tồn tại trên đĩa trước khi được tiêm.
- Tiêm code từ xa: Một tiến trình độc hại ghi code vào không gian bộ nhớ của tiến trình mục tiêu và buộc nó thực thi. Code có thể là một khối shellcode (nghĩa là không phải là tệp PE) hoặc nó có thể là một tệp PE với bảng nhập được cấu hình trước cho tiến trình mục tiêu.
- Tiêm DLL phản chiếu: Một tiến trình độc hại ghi một DLL (dưới dạng một chuỗi byte) vào không gian bộ nhớ của tiến trình mục tiêu. DLL xử lý việc khởi tạo của nó mà không cần sự trợ giúp của trình tải Windows. DLL không cần tồn tại trên đĩa trước khi được tiêm.
- Tiêm tiến trình trống: Một tiến trình độc hại khởi động một phiên bản mới của một tiến trình hợp pháp (chẳng hạn như lsass.exe) ở trạng thái tạm dừng. Trước khi tiếp tục nó, các phần của tệp thực thi được giải phóng và cấp lại với mã độc hại.

Như bạn sẽ tìm hiểu, kỹ thuật bạn sử dụng để phát hiện code injection phụ thuộc vào cách mà code đã được tiêm, đó là lý do tại sao chúng tôi phân biệt giữa các phương pháp khác nhau. Mặc dù Volatility cung cấp khả năng phát hiện tất cả các loại này, bạn vẫn cần đầu tư một số công sức phân tích để tìm hiểu khi nào sử dụng các plugin khác nhau và cách hiểu đúng đắn đầu ra của chúng.

Trong các mô tả tiếp theo, Tiến trình A là quá trình độc hại và Tiến trình B là mục tiêu.

### Remote DLL Injection

Kỹ thuật này thường được thực hiện theo các bước sau:
- Tiến trình A bật quyền đặc quyền gỡ lỗi (SE_DEBUG_PRIVILEGE) để cho phép nó đọc và ghi vào bộ nhớ của các tiến trình khác như một trình gỡ lỗi.
-. Tiến trình A mở một xử lý cho Tiến trình B bằng cách gọi OpenProcess. Nó phải yêu cầu ít nhất PROCESS_CREATE_THREAD, PROCESS_VM_OPERATION và PROCESS_VM_WRITE.
- Tiến trình A cấp phát bộ nhớ trong Tiến trình B bằng cách sử dụng VirtualAllocEx. Bảo vệ thường là PAGE_READWRITE.
   Tiến trình A chuyển một chuỗi vào bộ nhớ của Tiến trình B bằng cách gọi WriteProcessMemory. Chuỗi này xác định đường dẫn đầy đủ trên đĩa đến DLL độc hại và nó được ghi vào địa chỉ đã cấp phát trong bước trước đó.
- Tiến trình A gọi CreateRemoteThread để bắt đầu một luồng mới trong Tiến trình B thực thi hàm LoadLibrary. Tham số của luồng được đặt thành đường dẫn đầy đủ đến DLL độc hại, đã tồn tại trong bộ nhớ của Tiến trình B.
- Tại thời điểm này, quá trình tiêm đã hoàn tất và Tiến trình B đã tải DLL. Tiến trình A gọi VirtualFree để giải phóng bộ nhớ chứa đường dẫn của DLL.
- Tiến trình A gọi CloseHandle trên quá trình của Tiến trình B để dọn dẹp.

### DLL Injection Detection

Xét về việc LoadLibrary được sử dụng để tải DLL, không có cách nào chắc chắn phân biệt giữa DLL độc hại và các DLL được tải một cách rõ ràng trong Quy trình B. Các danh sách VAD và PEB gần như giống nhau về mặt dữ liệu siêu dữ liệu cho tất cả các module được tải bằng cùng một API. Nói cách khác, DLL được tiêm không nhất thiết phải bị ẩn ở thời điểm này; nó có thể hoàn toàn hiển thị với dlllist hoặc các công cụ như Process Explorer đang chạy trên hệ thống thời gian thực. Tuy nhiên, trừ khi bạn biết chính xác tên của DLL, nó có thể dễ dàng trộn lẫn với các module hợp pháp.

Tuy nhiên, có hai yếu tố có thể làm cho việc phát hiện trở nên khả thi. Trước tiên, nếu DLL bị tiêm cố gắng ẩn tránh khỏi các công cụ trên hệ thống thời gian thực sau khi được tải (bằng cách gỡ liên kết _LDR_DATA_TABLE_ENTRY của nó từ một hoặc nhiều trong các danh sách được sắp xếp), bạn có thể sử dụng ldrmodules để phát hiện nó. Thứ hai là nếu DLL bị tiêm được đóng gói và quá trình giải nén sao chép mã giải nén vào một khu vực bộ nhớ mới, bạn có thể phát hiện nó bằng cách sử dụng malfind (được miêu tả bên dưới). Nếu không xảy ra bất kỳ yếu tố nào trong hai trường hợp trên, bạn phải quay trở lại các phân tích thông thường liên quan đến ngữ cảnh, tên đường dẫn, quét Yara, dấu thời gian tải DLL (xem Chương 18), và các phương pháp khác để xác định và phân tích DLL được tiêm.

### Remote Code Injection

Phương pháp này bắt đầu với hai bước giống như tiêm DLL từ xa. Quy trình A cho phép quyền gỡ lỗi và sau đó mở một handle đến quy trình B. Nó hoàn tất như sau:

- Quy trình A cấp phát bộ nhớ trong quy trình B với bảo vệ PAGE_EXECUTE_READWRITE. Cấp phép bảo vệ này là cần thiết để cho phép quy trình A ghi vào bộ nhớ và quy trình B đọc và thực thi nó.

- Quy trình A truyền một khối mã vào quy trình B bằng cách sử dụng WriteProcessMemory.

- Quy trình A gọi CreateRemoteThread và trỏ địa chỉ bắt đầu của luồng vào một hàm trong khối mã được truyền.


### Code Injection Detection

Trình cắm malfind được thiết kế để tìm kiếm các lần tiêm mã từ xa xảy ra như đã mô tả trước đó. Chúng tôi đã gợi ý về điều này nhiều lần trong Chương 7, nói về các đặc điểm và cờ VAD. Ý tưởng là sẽ có một khu vực bộ nhớ riêng có thể đọc, ghi và thực thi (nghĩa là không có ánh xạ tệp) với tất cả các trang đã cam kết (chúng tôi sử dụng một số biến thể của các tiêu chí này để phát hiện). Khu vực sẽ chứa một tiêu đề PE và / hoặc các lệnh CPU hợp lệ. Dưới đây là một ví dụ về một khối mã mà Stuxnet đã tiêm vào services.exe:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204154.png)

Kết quả đầu ra hiển thị một bản xem trước của dữ liệu dưới dạng hex dump và disassembly, bắt đầu từ địa chỉ cơ sở của khu vực được tiêm vào (0x013f0000). Trong một số trường hợp, bạn sẽ tận dụng hex dump để xác định xem khu vực có độc hại không (ví dụ, bạn thấy một chữ ký MZ); trong những trường hợp khác, bạn sẽ cần dựa vào disassembly. Dưới đây là một ví dụ cho thấy disassembly rất hữu ích. Trong ví dụ sau về việc phát hiện Carberp, không có chữ ký MZ tồn tại vì nó chỉ là một khối shellcode:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204208.png)

Khu vực này tại địa chỉ 0x9d0000 đáng để nghiên cứu kỹ hơn vì disassembly chứa các hướng dẫn CPU hợp lý. Ví dụ, các điểm đến của JMP là hợp lệ, và sự kết hợp giữa MOV EDI, EDI được tiếp theo bởi PUSH EBP cho thấy đây là phần đầu của một hàm (function prologue). Khi bạn xem xét kết quả của malfind, hãy nhớ rằng các chương trình có thể cấp phát bộ nhớ riêng có thể thực thi với mục đích hợp lệ. Ví dụ, khu vực sau đây trong csrss.exe không phải là do malware tiêm vào; nó được phát hiện bởi plugin do sự tương đồng với các khu vực tiêm vào:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204225.png)

Phần disassembly không hợp lý trong trường hợp này. Ví dụ, có một lệnh ENTER, nhưng không có lệnh LEAVE. Có một lệnh nhảy điều kiện (JNO), nhưng không có điều kiện. Hơn nữa, đích của lệnh nhảy dẫn đến địa chỉ 0x7f6f0007, một địa chỉ không chứa lệnh theo đúng kiểu căn chỉnh hiện tại. Vùng nhớ này không có vẻ độc hại khi nhìn qua lần đầu. Hãy xem xét ví dụ tiếp theo, liên quan đến Coreflood:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204240.png)

Hầu hết các nhà phân tích cho rằng phạm vi này tại địa chỉ 0x7ff80000 là một false positive (kết quả sai). Bản xem trước của dữ liệu cho thấy cả hex dump và disassembly chỉ chứa các giá trị zero. Tuy nhiên, hãy nhớ rằng đây chỉ là một bản xem trước của dữ liệu. CPU không nhất thiết phải bắt đầu thực thi mã tại vị trí 0 trong vùng nhớ bị inject; nó có thể dễ dàng trỏ đến một vị trí bất kỳ trong phạm vi đó. Trong trường hợp này, tính năng antidumping của Coreflood đã xóa bỏ phần header PE (được chiếm bởi trang đầu tiên) bằng cách ghi đè nó bằng các giá trị zero. Tuy nhiên, nếu bạn sử dụng volshell để disassemble mã trong trang thứ hai (0x7ff81000), bạn sẽ nhìn thấy hàm chính của mã độc:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204253.png)

Malware có thể sử dụng một số thủ thuật để ẩn trong bộ nhớ của quy trình. Việc xác minh mã trong các khu vực này thường yêu cầu quen thuộc với lập trình Assembly vì mã độc có thể trông rất giống với mã hợp lệ. Sau khi malfind giúp bạn thu hẹp các khả năng xuống một mức quản lý được, bạn vẫn phải áp dụng một số kiến thức và bối cảnh vào quá trình điều tra. Bạn cũng có thể cung cấp một thư mục đầu ra (--dump-dir) khi gọi malfind, và nó sẽ tự động trích xuất các khu vực nghi ngờ. Sau đó, bạn có thể chạy lệnh strings hoặc các công cụ quét chữ ký trên các tệp đã được trích xuất.

>**CẢNH BÁO:**<br> Coreflood đã ngăn nhiều công cụ khác nhau khắc phục bản sao nhị phân từ bộ nhớ bằng cách xoá bỏ phần đầu của PE header. Cách tiếp cận chống pháp sẽ gây phiền hà, nhưng không nên dừng bạn lại. Chỉ cần sử dụng vaddump để trích xuất khu vực bộ nhớ và sau đó sử dụng một trình chỉnh sửa hex hoặc trình chỉnh sửa PE để xây dựng mẫu PE header riêng của bạn. Để biết thêm thông tin, hãy xem "Recovering Coreflood Binaries with Volatility": http://mnin.blogspot.com/2008/11/recovering-coreflood-binarieswith.html.

### Reflective DLL Injection

Phương pháp này là một sự kết hợp của hai phương pháp đã được thảo luận trước đó. Nội dung được chuyển từ Process A sang Process B là một DLL (không phải một khối mã shellcode), nhưng sau khi tồn tại trong Process B, nó tự khởi tạo thay vì gọi LoadLibrary. Phương pháp này có một số lợi thế chống pháp sẽ:
- LoadLibrary chỉ tải thư viện từ đĩa. Vì phương pháp này không phụ thuộc vào API, DLL được tiêm vào không bao giờ cần được ghi vào lưu trữ lâu dài. Nó có thể được tải vào bộ nhớ trực tiếp từ mạng (ví dụ, khi khai thác một lỗ hổng tràn bộ đệm từ xa).
- Bởi vì tránh sử dụng LoadLibrary, cấu trúc siêu dữ liệu _LDR_DATA_TABLE_ENTRY không được tạo ra. Do đó, ba danh sách trong PEB sẽ không có bản ghi của DLL này được tải.

>**Chú ý:**<br> Để biết thêm thông tin về kỹ thuật này, bạn có thể tham khảo các tài liệu sau:
>- Remote Library Injection của skape (http://www.nologin.org/Downloads/Papers/remote-library-injection.pdf).
>- Reflective DLL Injection của Steven Fewer: (http://www.harmonysecurity.com/files/HS-P005_ReflectiveDllInjection.pdf).
>- Bạn cũng có thể kiểm tra mã nguồn và biên dịch các tệp nhị phân kiểm tra của riêng mình từ kho lưu trữ sau: https://github.com/stephenfewer/ReflectiveDLLInjection.

### Reflective DLL Injection Detection

Bạn có thể phát hiện kỹ thuật này bằng cách sử dụng malfind, như đã thảo luận trước đó. Dưới đây là một đoạn mã từ tệp LoadLibraryR.c của dự án ReflectiveDLLInjection:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204308.png)

Do các tùy chọn được chọn trong quá trình cấp phát, VAD (Virtual Address Descriptor) trong quá trình chủ sử dụng (host process) chứa DLL phù hợp với tiêu chí của plugin malfind.

>**Chú ý** <br>Các payload VNC và Meterpreter của Metasploit đều dựa trên phương pháp Reflective DLL Injection. Để biết thêm thông tin, bạn có thể xem trang http://www.offensive-security.com/metasploit-unleashed/Payload_Types. Bạn có thể phát hiện các loại tấn công này trong bộ nhớ sử dụng các plugin đã được thảo luận trong chương này.

### Hollow Process Injection

Với các phương pháp injection đã được thảo luận trước đó, quy trình mục tiêu vẫn tiếp tục chạy và chỉ thực thi mã bổ sung (độc hại) thay mặt cho phần mềm độc hại. Tuy nhiên, với kỹ thuật "process hollowing", phần mềm độc hại khởi chạy một phiên bản mới của một quy trình hợp pháp, chẳng hạn như lsass.exe. Trước khi luồng đầu tiên của quy trình bắt đầu, phần mềm độc hại giải phóng bộ nhớ chứa mã lsass.exe (nhưng giữ lại các cấu trúc dữ liệu PEB và các cấu trúc dữ liệu khác), và sau đó thay thế nó bằng mã độc hại. Trong ý nghĩa này, quy trình chỉ thực thi mã độc hại cho phần còn lại của thời gian sống của quy trình. Hình 8-9 cho thấy một bố cục bộ nhớ trước và sau quá trình đó.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204322.png)

#### How to Hollow a Process

Các bước sau mô tả cách thực hiện cuộc tấn công như vậy. Recipe 15-8 trong "Malware Analyst’s Cookbook" cũng bao gồm mã nguồn C liên quan cho mỗi bước.

1. Khởi chạy một phiên bản mới của một quy trình hợp pháp (ví dụ: C:\windows\system32\lsass.exe), nhưng tạm dừng luồng đầu tiên của nó. Lúc này, ImagePathName trong PEB của quy trình mới xác định đường dẫn đầy đủ đến lsass.exe hợp pháp.

2. Lấy nội dung cho mã độc hại thay thế. Nội dung này có thể đến từ một tệp trên đĩa, một bộ đệm hiện có trong bộ nhớ hoặc thông qua mạng.

3. Xác định địa chỉ cơ bản (ImageBase) của quy trình lsass.exe, sau đó giải phóng hoặc hủy ánh xạ vùng nhớ chứa quy trình đó. Lúc này, quy trình chỉ là một "thùng rỗng" (các DLL, ngăn xếp và xử lý đã vẫn tồn tại, nhưng không có mã thực thi của quy trình).

4. Cấp phát một đoạn bộ nhớ mới trong lsass.exe và đảm bảo rằng bộ nhớ có thể đọc, ghi và thực thi. Bạn có thể tái sử dụng cùng ImageBase hoặc sử dụng một ImageBase khác.

5. Sao chép tiêu đề PE cho quy trình độc hại vào bộ nhớ mới được cấp phát trong lsass.exe.

6. Sao chép từng phần PE cho quy trình độc hại vào địa chỉ ảo thích hợp trong lsass.exe.

7. Thiết lập địa chỉ bắt đầu cho luồng đầu tiên (luồng đã được tạm dừng) để trỏ vào giá trị AddressOfEntryPoint của quy trình độc hại.

8. Tiếp tục luồng. Lúc này, quy trình độc hại bắt đầu thực thi trong bộ nhớ của lsass.exe. ImagePathName trong PEB vẫn trỏ đến C:\windows\system32\lsass.exe.

#### Detection

Stuxnet tạo ra hai phiên bản mới của lsass.exe và thay thế mã của chúng, chính như các bước trước đã mô tả. Khi bạn liệt kê các tiến trình, bạn sẽ thấy như sau:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204338.png)

Có ba tiến trình (PID 680, 868 và 1928), nhưng chỉ có một tiến trình lsass.exe thực sự. Trực giác có thể nói cho bạn biết rằng tiến trình bắt đầu trước dựa trên thời gian tạo (PID 680) là phiên bản hợp lệ, nhưng chúng tôi sẽ chỉ cho bạn cách xác nhận. Trước tiên, bạn có thể xem đường dẫn đầy đủ đến tệp thực thi và/hoặc dòng lệnh của nó. Lệnh sau đây sẽ hiển thị thông tin này cũng như giá trị ImageBase cho các tiến trình:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204351.png)

Các đường dẫn được quảng cáo đều giống nhau (mặc dù có hai đường dẫn có một tập hợp bổ sung của dấu ngoặc kép xung quanh đường dẫn) bởi vì dữ liệu trong PEB, bao gồm ImageBase, được khởi tạo khi tiến trình được tạo, và tất cả các tiến trình bắt đầu giống nhau. Tuy nhiên, do đã bị thay thế, các đặc điểm của VAD cho vùng chứa ImageBase thay đổi rất nhiều. Chỉ có phiên bản hợp lệ (PID 680) vẫn có một bản sao của tệp lsass.exe được ánh xạ vào vùng này:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204422.png)
![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204434.png)

Như một phương án thay thế cho các bước nhiều bước bạn vừa thấy, bạn cũng có thể bỏ qua trực tiếp đến ldrmodules. Hãy nhớ rằng tệp thực thi của tiến trình được thêm vào danh sách load order và memory order module trong PEB. Do đó, khi ldrmodules liên kết thông tin với các tệp được ánh xạ vào bộ nhớ trong VAD, bạn sẽ thấy sự không phù hợp. Dưới đây là một ví dụ:

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204448.png)

Bởi vì lsass.exe đã bị giải phóng ra khỏi bộ nhớ (unmapped), một tên không còn được liên kết với vùng nhớ tại địa chỉ 0x01000000. Tuy nhiên, việc gọi hàm NtUnmapViewOfSection (bước 3) không làm mất các siêu dữ liệu của PEB, vì vậy những cấu trúc này vẫn giữ một bản ghi về việc ánh xạ ban đầu trong danh sách load order và memory order.

>**>Lưu ý:**<b> Để biết thêm thông tin về phương pháp hollow process, bạn có thể tham khảo các bài viết sau:
>- Phân tích Malware Hollow Process của Eric Monti: http://blog.spiderlabs.com/2011/05/analyzing-malware-hollow-processes.html
>- Gỡ lỗi Hollow Processes của Alexander Hanel: http://hooked-on-mnemonics.blogspot.com/2013/01/debugging-hollow-processes.html

### Postprocessing Dumped Code

Sau khi xác định các vùng mã đã bị tiêm chích, bạn có thể trích xuất chúng ra đĩa để phân tích tĩnh. Trong hầu hết các trường hợp, bạn chỉ cần sửa ImageBase trong PE header đã trích xuất để phù hợp với vị trí của nó trong bộ nhớ, sau đó bạn có thể tải tệp lên IDA Pro. Nếu các hàm được nhập khẩu không hiển thị vào thời điểm đó, hãy sử dụng plugin impscan để tạo thông tin ngữ cảnh từ bản trích xuất bộ nhớ và nhập dữ liệu như nhãn vào IDA. Cùng với việc tiếp tục các quá trình, DLL hoặc trình điều khiển kernel mà bạn trích xuất từ bộ nhớ, không chỉ là các vùng bị tiêm chích. Recipe 16-8 (“Scanning for Imported Functions with Impscan”) trong Malware Analyst’s Cookbook mô tả khả năng này một cách cụ thể hơn.
Mặc dù hầu hết mã bạn trích xuất từ bộ nhớ đều tự chứa (ví dụ: một vùng duy nhất chứa mã thực thi và các biến đọc / ghi), nhưng không phải lúc nào cũng như vậy, đặc biệt là với Poison Ivy khi chức năng "melt" của nó được bật. Tính năng này khiến RAT tan rã vào không gian bộ nhớ của quá trình, phân tán các mảnh nhỏ của mã của nó khắp nơi. Hình 8-10 cho thấy ảnh hưởng của điều này đối với khả năng xây dựng lại tệp nhị phân ban đầu để phân tích tĩnh.

![](https://github.com/HuyThang25/Image/blob/main/Screenshot%202023-08-01%20204501.png)

Poison Ivy được phân tán qua hơn 20 vùng VAD khác nhau. Trong bài viết Reverse Engineering Poison Ivy's Injected Code Fragments (http://volatility-labs.blogspot.com/2012/10/reverse-engineering-poison-ivys.html), chúng tôi trình bày cách xây dựng một plugin tùy chỉnh cho Volatility nhằm tái tạo, trong tối đa có thể, tệp nhị phân gốc từ các đoạn mã và đưa chúng trở lại vào ngữ cảnh.

>**CẢNH BÁO**<br>
Việc phân mảnh mã chèn của Poison Ivy là một kỹ thuật chống pháp luật rất mạnh mẽ. Việc thiết kế plugin pivydasm không đơn giản và đã mất một lượng thời gian đáng kể. May mắn là mặc dù mã được phân tán trong nhiều vùng VAD, chúng ta vẫn có thể theo dõi mã bằng cách disassemble trong volshell. Việc giải mã chuỗi và cuộc gọi API cũng có thể thực hiện được, bởi vì chúng ta có quyền truy cập vào toàn bộ không gian bộ nhớ của quá trình.

## Tổng quan 

Các kỹ năng được mô tả trong chương này sẽ giúp các nhà phân tích phát hiện và phân tích phần lớn mã độc trong môi trường thực. Cụ thể, bạn đã học cách nhận diện mã chèn, xác định các DLL đáng ngờ, dump các file nhị phân đã giải nén và khai thác các tạo vật trong khối môi trường của quá trình. Kể từ khi chúng ta có thể nhớ, mã độc và rootkit đã sử dụng các kỹ thuật để ẩn mình khỏi các công cụ quản trị và bảo mật trên hệ thống hoạt động; và giờ đây bạn đã hiểu cách chúng hoạt động. Hơn nữa, bạn đã thấy các ví dụ về kỹ thuật pháp y trong các trường hợp liên quan đến các chiến dịch mã độc lớn (như Zeus và Coreflood) cũng như các công cụ tấn công nhắm mục tiêu cao cấp như Stuxnet.
